<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.57.2" />


<title>Tidy Pairwise Operations - Bryan&#39;s website</title>
<meta property="og:title" content="Tidy Pairwise Operations - Bryan&#39;s website">


  <link href='/favicon.ico' rel='icon' type='image/x-icon'/>



  








<link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="/css/fonts.css" media="all">
<link rel="stylesheet" href="/css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/" class="nav-logo">
    <img src="/images/bryan_edit.jpg"
         width="60"
         height="60"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="https://twitter.com/brshallo">Twitter</a></li>
    
    <li><a href="https://github.com/brshallo">GitHub</a></li>
    
    <li><a href="https://www.linkedin.com/in/bryanshalloway/">LinkedIn</a></li>
    
    <li><a href="https://www.youtube.com/channel/UCDVMC4-VRU-tR2Z4nYc1mDA">YouTube</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">16 min read</span>
    

    <h1 class="article-title">Tidy Pairwise Operations</h1>

    
    <span class="article-date">2020-05-31</span>
    

    <div class="article-content">
      

<div id="TOC">
<ul>
<li><a href="#data">Data</a></li>
<li><a href="#overview">Overview</a><ul>
<li><a href="#i.-nest-and-pivot">I. Nest and pivot</a></li>
<li><a href="#ii.-expand-combinations">II. Expand combinations</a></li>
<li><a href="#iii.-filter-redundancies">III. Filter redundancies</a></li>
<li><a href="#iv.-perform-operations">IV. Perform operation(s)</a></li>
<li><a href="#v.-reshape-re-pivot-unnest">V. Reshape, re-pivot &amp; unnest</a></li>
<li><a href="#vi.-bind-back-to-data">VI. Bind back to data</a></li>
</ul></li>
<li><a href="#functionalize">Functionalize</a></li>
<li><a href="#when-is-this-approach-innapropriate">When is this approach innapropriate?</a></li>
<li><a href="#appendix">Appendix</a><ul>
<li><a href="#interactions-example-tidymodels">Interactions example, tidymodels</a></li>
<li><a href="#expand-via-join">Expand via join</a></li>
<li><a href="#nested-tibbles">Nested tibbles</a></li>
<li><a href="#pivot-and-then-summarise">Pivot and then summarise</a></li>
<li><a href="#session-info">Session info</a></li>
</ul></li>
</ul>
</div>

<p>Say you want to map an operation or list of operations across all two-way<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> combinations of a set of variables/columns in a dataframe. For example, you may be doing feature engineering and want to create a set of interaction terms, ratios, etc.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>. You may be interested in computing a summary statistic across all pairwise combinations of a given set of variables<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>. In some cases there may be an excellent pairwise implementation already available, e.g. R’s <code>cor()</code> function for computing correlations<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>. In other cases one may not exist, is not easy to use, or is not in a style you prefer. In this post I’ll walk through an example<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> explaining code and steps for setting-up arbitrary pairwise operations across sets of variables.</p>
<p><em>I’ll break my approach down into several steps:</em></p>
<p>I. Nest and pivot<br />
II. Expand combinations<br />
III. Filter redundancies<br />
IV. Perform operation(s)<br />
V. Reshape, re-pivot &amp; unnest<br />
VI. Bind back to data</p>
<p><strong>Relevant software and style:</strong></p>
<p>I will primarily be using R’s <code>tidyverse</code> packages. I make frequent use of lists as columns within dataframes – if you are new to these, see my previous <a href="https://www.youtube.com/watch?v=gme4Fb9JVjk">talk</a> and the resources<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a> I link to in the description.</p>
<p>Throughout this post, wherever I write “dataframe” I really mean “tibble” (a dataframe with minor changes to default options and slightly prettier printing behavior). Also note that I am using <code>dplyr</code> 0.8.3 rather than the newly released 1.0.0<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>.</p>
<pre class="r"><code>library(tidyverse)</code></pre>
<div id="data" class="section level1">
<h1>Data</h1>
<p>I’ll use the ames housing dataset across examples.</p>
<pre class="r"><code>ames &lt;- AmesHousing::make_ames()</code></pre>
<p>Specifically, I’ll focus on ten numeric columns that, based on a random sample of 1000 rows, show the highest correlation with <code>Sale_Price</code><a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>.</p>
<pre class="r"><code>set.seed(2020)
ames_cols &lt;- ames %&gt;% 
  select_if(is.numeric) %&gt;% 
  sample_n(1000) %&gt;% 
  corrr::correlate() %&gt;% 
  corrr::focus(Sale_Price) %&gt;% 
  arrange(-abs(Sale_Price)) %&gt;% 
  head(10) %&gt;% 
  pull(rowname)

ames_subset &lt;- select(ames, ames_cols) %&gt;% 
  mutate_all(as.double) %&gt;% 
  # standardize variables
  mutate_all(~(. - mean(.)) / sd(.))</code></pre>
</div>
<div id="overview" class="section level1">
<h1>Overview</h1>
<div id="i.-nest-and-pivot" class="section level2">
<h2>I. Nest and pivot</h2>
<p>There are a variety of ways to make lists into columns within a dataframe. In the example below, I use <code>summarise_all(ames_subset, list)</code> to create a one row dataframe where each column is a list containing a single element and each individual element corresponds with a numeric vector of length 2930.</p>
<p>After nesting, I pivot<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a> the columns leaving a dataframe with two columns:</p>
<ul>
<li><code>var</code> the variable names</li>
<li><code>vector</code> a list where each element contains the associated vector</li>
</ul>
<pre class="r"><code>df_lists &lt;- ames_subset %&gt;% 
  summarise_all(list) %&gt;% 
  pivot_longer(cols = everything(), 
               names_to = &quot;var&quot;, 
               values_to = &quot;vector&quot;) %&gt;% 
  print()</code></pre>
<pre><code>## # A tibble: 10 x 2
##    var            vector       
##    &lt;chr&gt;          &lt;list&gt;       
##  1 Gr_Liv_Area    &lt;dbl [2,930]&gt;
##  2 Garage_Cars    &lt;dbl [2,930]&gt;
##  3 Garage_Area    &lt;dbl [2,930]&gt;
##  4 Total_Bsmt_SF  &lt;dbl [2,930]&gt;
##  5 First_Flr_SF   &lt;dbl [2,930]&gt;
##  6 Year_Built     &lt;dbl [2,930]&gt;
##  7 Full_Bath      &lt;dbl [2,930]&gt;
##  8 Year_Remod_Add &lt;dbl [2,930]&gt;
##  9 TotRms_AbvGrd  &lt;dbl [2,930]&gt;
## 10 Fireplaces     &lt;dbl [2,930]&gt;</code></pre>
<p>See <a href="#pivot-and-then-summarise">Pivot and then summarise</a> for a nearly identical approach with just an altered order of steps. Also see <a href="#nested-tibbles">Nested tibbles</a> for how you could create a list-column of dataframes<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a> rather than vectors.</p>
</div>
<div id="ii.-expand-combinations" class="section level2">
<h2>II. Expand combinations</h2>
<p>I then use <code>tidyr::nesting()</code> within <code>tidyr::expand()</code> to make all 2-way combinations.</p>
<pre class="r"><code>df_lists_comb &lt;- expand(df_lists,
                        nesting(var, vector),
                        nesting(var2 = var, vector2 = vector)) %&gt;% 
  print()</code></pre>
<pre><code>## # A tibble: 100 x 4
##    var        vector        var2           vector2      
##    &lt;chr&gt;      &lt;list&gt;        &lt;chr&gt;          &lt;list&gt;       
##  1 Fireplaces &lt;dbl [2,930]&gt; Fireplaces     &lt;dbl [2,930]&gt;
##  2 Fireplaces &lt;dbl [2,930]&gt; First_Flr_SF   &lt;dbl [2,930]&gt;
##  3 Fireplaces &lt;dbl [2,930]&gt; Full_Bath      &lt;dbl [2,930]&gt;
##  4 Fireplaces &lt;dbl [2,930]&gt; Garage_Area    &lt;dbl [2,930]&gt;
##  5 Fireplaces &lt;dbl [2,930]&gt; Garage_Cars    &lt;dbl [2,930]&gt;
##  6 Fireplaces &lt;dbl [2,930]&gt; Gr_Liv_Area    &lt;dbl [2,930]&gt;
##  7 Fireplaces &lt;dbl [2,930]&gt; Total_Bsmt_SF  &lt;dbl [2,930]&gt;
##  8 Fireplaces &lt;dbl [2,930]&gt; TotRms_AbvGrd  &lt;dbl [2,930]&gt;
##  9 Fireplaces &lt;dbl [2,930]&gt; Year_Built     &lt;dbl [2,930]&gt;
## 10 Fireplaces &lt;dbl [2,930]&gt; Year_Remod_Add &lt;dbl [2,930]&gt;
## # ... with 90 more rows</code></pre>
<p>See <a href="#expand-via-join">Expand via join</a> for an alternative approach using the <code>dplyr::*_join()</code> operations.</p>
<p><em>You could make a strong case that this step should be after <a href="#iii.-filter-redundancies">III. Filter redundancies</a><a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a>. However putting it beforehand makes the required code easier to write and to read.</em></p>
</div>
<div id="iii.-filter-redundancies" class="section level2">
<h2>III. Filter redundancies</h2>
<p>Filter-out redundant columns, sort the rows, better organize the columns.</p>
<pre class="r"><code>df_lists_comb &lt;- df_lists_comb %&gt;% 
  filter(!(var == var2)) %&gt;% 
  arrange(var, var2) %&gt;% 
  select(contains(&quot;var&quot;), everything()) %&gt;% 
  mutate(vars = paste0(var, &quot;.&quot;, var2)) %&gt;% 
  print()</code></pre>
<pre><code>## # A tibble: 90 x 5
##    var         var2          vector       vector2     vars                 
##    &lt;chr&gt;       &lt;chr&gt;         &lt;list&gt;       &lt;list&gt;      &lt;chr&gt;                
##  1 Fireplaces  First_Flr_SF  &lt;dbl [2,930~ &lt;dbl [2,93~ Fireplaces.First_Flr~
##  2 Fireplaces  Full_Bath     &lt;dbl [2,930~ &lt;dbl [2,93~ Fireplaces.Full_Bath 
##  3 Fireplaces  Garage_Area   &lt;dbl [2,930~ &lt;dbl [2,93~ Fireplaces.Garage_Ar~
##  4 Fireplaces  Garage_Cars   &lt;dbl [2,930~ &lt;dbl [2,93~ Fireplaces.Garage_Ca~
##  5 Fireplaces  Gr_Liv_Area   &lt;dbl [2,930~ &lt;dbl [2,93~ Fireplaces.Gr_Liv_Ar~
##  6 Fireplaces  Total_Bsmt_SF &lt;dbl [2,930~ &lt;dbl [2,93~ Fireplaces.Total_Bsm~
##  7 Fireplaces  TotRms_AbvGrd &lt;dbl [2,930~ &lt;dbl [2,93~ Fireplaces.TotRms_Ab~
##  8 Fireplaces  Year_Built    &lt;dbl [2,930~ &lt;dbl [2,93~ Fireplaces.Year_Built
##  9 Fireplaces  Year_Remod_A~ &lt;dbl [2,930~ &lt;dbl [2,93~ Fireplaces.Year_Remo~
## 10 First_Flr_~ Fireplaces    &lt;dbl [2,930~ &lt;dbl [2,93~ First_Flr_SF.Firepla~
## # ... with 80 more rows</code></pre>
<p>If your operation of interest is associative<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a>, apply a filter to remove additional redundant combinations.</p>
<pre class="r"><code>c_sort_collapse &lt;- function(...){
  c(...) %&gt;% 
    sort() %&gt;% 
    str_c(collapse = &quot;.&quot;)
}

df_lists_comb_as &lt;- df_lists_comb %&gt;% 
  mutate(vars = map2_chr(.x = var, .y = var2, .f = c_sort_collapse)) %&gt;%
  distinct(vars, .keep_all = TRUE)</code></pre>
</div>
<div id="iv.-perform-operations" class="section level2">
<h2>IV. Perform operation(s)</h2>
<p><strong>Example with summary statistic<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a>:</strong></p>
<p>At this point you can map any operation across each of the combinations of vectors contained in each row of your data. For example, let’s say we want to compute the p-value of the correlation coefficient for each pair<a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a>.</p>
<pre class="r"><code>pairs_cor_pvalues &lt;- df_lists_comb_as %&gt;% 
  mutate(cor_pvalue = map2(vector, vector2, cor.test) %&gt;% map_dbl(&quot;p.value&quot;),
         vars = fct_reorder(vars, -cor_pvalue)) %&gt;% 
  arrange(cor_pvalue) %&gt;% 
  print()</code></pre>
<pre><code>## # A tibble: 45 x 6
##    var        var2       vector     vector2    vars              cor_pvalue
##    &lt;chr&gt;      &lt;chr&gt;      &lt;list&gt;     &lt;list&gt;     &lt;fct&gt;                  &lt;dbl&gt;
##  1 First_Flr~ Total_Bsm~ &lt;dbl [2,9~ &lt;dbl [2,9~ First_Flr_SF.Tot~  0.       
##  2 Full_Bath  Gr_Liv_Ar~ &lt;dbl [2,9~ &lt;dbl [2,9~ Full_Bath.Gr_Liv~  0.       
##  3 Garage_Ar~ Garage_Ca~ &lt;dbl [2,9~ &lt;dbl [2,9~ Garage_Area.Gara~  0.       
##  4 Gr_Liv_Ar~ TotRms_Ab~ &lt;dbl [2,9~ &lt;dbl [2,9~ Gr_Liv_Area.TotR~  0.       
##  5 Year_Built Year_Remo~ &lt;dbl [2,9~ &lt;dbl [2,9~ Year_Built.Year_~  7.85e-301
##  6 First_Flr~ Gr_Liv_Ar~ &lt;dbl [2,9~ &lt;dbl [2,9~ First_Flr_SF.Gr_~  8.17e-244
##  7 Garage_Ca~ Year_Built &lt;dbl [2,9~ &lt;dbl [2,9~ Garage_Cars.Year~  1.57e-219
##  8 Full_Bath  TotRms_Ab~ &lt;dbl [2,9~ &lt;dbl [2,9~ Full_Bath.TotRms~  1.24e-210
##  9 First_Flr~ Garage_Ar~ &lt;dbl [2,9~ &lt;dbl [2,9~ First_Flr_SF.Gar~  8.16e-178
## 10 Garage_Ca~ Gr_Liv_Ar~ &lt;dbl [2,9~ &lt;dbl [2,9~ Garage_Cars.Gr_L~  4.80e-175
## # ... with 35 more rows</code></pre>
<p>For fun, let’s plot the most significant associations onto a bar graph.</p>
<pre class="r"><code>pairs_cor_pvalues %&gt;% 
  head(15) %&gt;% 
  mutate(cor_pvalue_nlog = -log(cor_pvalue)) %&gt;% 
  ggplot(aes(x = vars, 
             y = cor_pvalue_nlog, 
             fill = is.infinite(cor_pvalue_nlog) %&gt;% factor(c(T, F))))+
  geom_col()+
  coord_flip()+
  theme_bw()+
  labs(title = &quot;We are confident that garage area and # of garage cars are correlated&quot;,
       y = &quot;Negative log of p-value of correlation coefficient&quot;,
       x = &quot;Variable combinations&quot;,
       fill = &quot;Too large to\nmeaningfully\ndifferentiate:&quot;)+
  theme(plot.title.position = &quot;plot&quot;)</code></pre>
<p><img src="/post/2020-05-31-tidy-2-way-column-combinations_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<p>You could use this approach to calculate any summary statistic. For example, see <a href="https://gist.github.com/brshallo/dc3c1f2f34519ca2a8a68024bc3a22e5">gist</a> where I calculate the K-S statistics across each combination of a group of distributions.</p>
<p><strong>Example with transformations<a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a>:</strong></p>
<p>Back to the feature engineering example, perhaps we want to calculate the difference and quotient of each combination of our variables.</p>
<pre class="r"><code>new_features_prep1 &lt;- df_lists_comb %&gt;% 
  mutate(difference = map2(vector, vector2, `-`),
         ratio = map2(vector, vector2, `/`))</code></pre>
</div>
<div id="v.-reshape-re-pivot-unnest" class="section level2">
<h2>V. Reshape, re-pivot &amp; unnest</h2>
<p>These steps put our data back into a more traditional form consistent with our starting dataframe/tibble.</p>
<p><strong>Reshape:</strong></p>
<p>The goal is to get our dataframe back into a form similar to where it was at the end of <a href="#i.-nest-and-pivot">I. Nest and pivot</a> where we had two columns:</p>
<ul>
<li>one with our variable names</li>
<li>a second containing a list-column of vectors</li>
</ul>
<p><em>In this section at the end of each line of code is a number corresponding with the explanations below:</em></p>
<ol style="list-style-type: decimal">
<li>if we had done just one operation, this step would not be needed, but we did multiple operations and hence created multiple list-columns (<code>difference</code> and <code>ratio</code>) which we need to get into a single list-column</li>
<li>create new variable name that combines constituent variable names with name of transformation</li>
<li>remove old columns</li>
</ol>
<pre class="r"><code>new_features_prep2 &lt;- new_features_prep1 %&gt;% 
  pivot_longer(cols = c(difference, ratio)) %&gt;% # 1
  mutate(name_vars = str_c(var, name, var2, sep = &quot;.&quot;)) %&gt;% # 2
  select(name_vars, value) %&gt;% # 3
  print()</code></pre>
<pre><code>## # A tibble: 180 x 2
##    name_vars                          value        
##    &lt;chr&gt;                              &lt;list&gt;       
##  1 Fireplaces.difference.First_Flr_SF &lt;dbl [2,930]&gt;
##  2 Fireplaces.ratio.First_Flr_SF      &lt;dbl [2,930]&gt;
##  3 Fireplaces.difference.Full_Bath    &lt;dbl [2,930]&gt;
##  4 Fireplaces.ratio.Full_Bath         &lt;dbl [2,930]&gt;
##  5 Fireplaces.difference.Garage_Area  &lt;dbl [2,930]&gt;
##  6 Fireplaces.ratio.Garage_Area       &lt;dbl [2,930]&gt;
##  7 Fireplaces.difference.Garage_Cars  &lt;dbl [2,930]&gt;
##  8 Fireplaces.ratio.Garage_Cars       &lt;dbl [2,930]&gt;
##  9 Fireplaces.difference.Gr_Liv_Area  &lt;dbl [2,930]&gt;
## 10 Fireplaces.ratio.Gr_Liv_Area       &lt;dbl [2,930]&gt;
## # ... with 170 more rows</code></pre>
<p><strong>Re-pivot and unnest:</strong></p>
<p>Next we simply apply the inverse of those operations performed in <a href="#i.-nest-and-pivot">I. Nest and pivot</a>.</p>
<pre class="r"><code>new_features &lt;- new_features_prep2 %&gt;% 
  pivot_wider(values_from = value,
              names_from = name_vars) %&gt;%
  unnest(cols = everything())</code></pre>
<p>The new features will add a good number of columns onto our original dataset<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a>.</p>
<pre class="r"><code>dim(new_features)</code></pre>
<pre><code>## [1] 2930  180</code></pre>
</div>
<div id="vi.-bind-back-to-data" class="section level2">
<h2>VI. Bind back to data</h2>
<p>I then bind the new features back onto the original subsetted dataframe.</p>
<pre class="r"><code>ames_data_features &lt;- bind_cols(ames_subset, new_features)</code></pre>
<p>At which point I could do further exploring, feature engineering, model building, etc.</p>
</div>
</div>
<div id="functionalize" class="section level1">
<h1>Functionalize</h1>
<p>I put these steps into a few functions found at <a href="https://gist.github.com/brshallo/f92a5820030e21cfed8f823a6e1d56e1">this gist</a><a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a>.</p>
<pre class="r"><code>devtools::source_gist(&quot;https://gist.github.com/brshallo/f92a5820030e21cfed8f823a6e1d56e1&quot;)</code></pre>
<p><code>operations_combinations()</code> takes in your dataframe, the set of numeric columns to create pairwise combinations from, and a list of functions<a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a> to apply.</p>
<pre class="r"><code>ames_data_features_example &lt;- ames %&gt;% 
  keep(is.numeric) %&gt;% 
  mutate_all(as.double) %&gt;% 
  mutate_all(~(. - mean(.)) / sd(.))

ames_data_features_example &lt;- operations_combinations(
  df = ames_data_features_example,
  one_of(ames_cols),
  funs = list(&quot;/&quot;, &quot;-&quot;),
  funs_names = list(&quot;ratio&quot;, &quot;difference&quot;),
  associative = FALSE
)</code></pre>
<p>To keep things simple, I’m going to remove any columns that contain any NA’s or infinite values. I’ll also use a random sample of just 1500 rows.</p>
<pre class="r"><code>features_keep &lt;- ames_data_features_example %&gt;% 
  summarise_all(~sum(is.na(.) | is.infinite(.))) %&gt;% 
  gather() %&gt;% # gather() is an older version of pivot_longer() w/ fewer features
  filter(value == 0) %&gt;% 
  pull(key)

set.seed(1234)
ames_sp_features_subset &lt;- ames_data_features_example %&gt;% 
  select(features_keep) %&gt;% 
  sample_n(1500)</code></pre>
<p>Next maybe you are interested in seeing the p-value of the correlation coefficient of each of your features with <code>Sale_Price</code>.</p>
<p>Calculate p.values and plot these on a histogram.</p>
<pre class="r"><code>ames_sp_features_subset %&gt;% 
  select(-Sale_Price) %&gt;% 
  summarise_all(~cor.test(., ames_sp_features_subset$Sale_Price)$p.value) %&gt;% 
  gather() %&gt;% 
  ggplot(aes(x = -log(value)))+
  geom_histogram()+
  scale_x_log10()+
  labs(title = &quot;Distribution of correlations with Sale_Price&quot;,
     x = &quot;Negative log of p-value of correlation coefficient&quot;)</code></pre>
<p><img src="/post/2020-05-31-tidy-2-way-column-combinations_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<p>If doing predictive modeling or inference you might fit this into a <code>tidymodels</code> pipeline or other framework. For some brief notes on this see <a href="#interactions-example-tidymodels">Interactions example, tidymodels</a>.</p>
</div>
<div id="when-is-this-approach-innapropriate" class="section level1">
<h1>When is this approach innapropriate?</h1>
<p>Combinatorial growth is very fast<a href="#fn19" class="footnote-ref" id="fnref19"><sup>19</sup></a>. As you increase either the number of variables in your pool or the size of each set, you will quickly bump into computational limitations.</p>
<p>Tidyverse packages are optimized to be computationally efficient. However operations with matrices or other specialized formats<a href="#fn20" class="footnote-ref" id="fnref20"><sup>20</sup></a> are generally faster<a href="#fn21" class="footnote-ref" id="fnref21"><sup>21</sup></a> than with dataframes/tibbles. If you are running into computational challenges but prefer to stick with a tidyverse aesthetic (which uses dataframes as a cornerstone), you might:</p>
<ul>
<li>Use heuristics to reduce the number of variables or operations you need to perform (e.g. take a sample, use a preliminary filter, a step-wise like iteration, etc.)</li>
<li>Look for packages that abstract the storage and computationally heavy operations away<a href="#fn22" class="footnote-ref" id="fnref22"><sup>22</sup></a> and then return back an output in a convenient form<a href="#fn23" class="footnote-ref" id="fnref23"><sup>23</sup></a></li>
<li>Improve the efficiency of your code (e.g. <em>filter redundancies</em> before rather than after <em>expanding combinations</em>)<a href="#fn24" class="footnote-ref" id="fnref24"><sup>24</sup></a></li>
<li>Consider parralelizing</li>
<li>Use matrices<a href="#fn25" class="footnote-ref" id="fnref25"><sup>25</sup></a></li>
</ul>
<p>For example, you <em>could</em> use an approach like the one I walk through to calculate the pairwise correlations between each of your variables. However, the <code>cor()</code> function would do this much more efficiently (or you could also use the <code>corrr</code> package within the <code>tidymodels</code> suite which calls <code>cor()</code> in the back-end<a href="#fn26" class="footnote-ref" id="fnref26"><sup>26</sup></a>).</p>
<p>However, for many operations…</p>
<ul>
<li>there may not be an efficient pairwise implementation available / accessible</li>
<li>the slower computation may not matter or can be mitigated in some way</li>
</ul>
<p>These situations<a href="#fn27" class="footnote-ref" id="fnref27"><sup>27</sup></a> are where the approach I walked through is most appropriate.</p>
</div>
<div id="appendix" class="section level1">
<h1>Appendix</h1>
<div id="interactions-example-tidymodels" class="section level2">
<h2>Interactions example, tidymodels</h2>
<p>A good example for creating and evaluating interaction terms<a href="#fn28" class="footnote-ref" id="fnref28"><sup>28</sup></a> is in <a href="http://www.feat.engineering/complete-enumeration.html#complete-enumeration-simple-screening">The Brute-Force Approach to Identifying Predictive Interactions, Simple Screening</a> section of <em>Max Kuhn</em> and <em>Kjell Johnson’s</em> (free) online book “Feature Engineering and Selection: A Practical Approach for Predictive Models”.</p>
<p>The <a href="https://github.com/topepo/FES/blob/master/07_Detecting_Interaction_Effects/7_04_The_Brute-Force_Approach_to_Identifying_Predictive_Interactions/ames_pairwise.R">source code</a> shows another approach for combining variables. The author uses…</p>
<ul>
<li><code>combn()</code> to create all combinations of variable names which are then…</li>
<li>turned into formulas and passed into <code>recipes::step_interact()</code>, specifying the new columns to be created<a href="#fn29" class="footnote-ref" id="fnref29"><sup>29</sup></a>…</li>
<li>for each interaction term…</li>
<li>in each associated model being evaluated</li>
</ul>
<p>The example uses a mix of packages and styles and is not a purely tidy approach – <code>tidymodels</code> has also gone through a lot of development since “Feature Engineering and Selection…” was published in 2019<a href="#fn30" class="footnote-ref" id="fnref30"><sup>30</sup></a>. Section 11.2 on <a href="http://www.feat.engineering/greedy-simple-filters.html">Greedy Search Methods, Simple Filters</a> is also highly relevant.</p>
</div>
<div id="expand-via-join" class="section level2">
<h2>Expand via join</h2>
<p>You can take advantage of join<a href="#fn31" class="footnote-ref" id="fnref31"><sup>31</sup></a> behavior to create all possible row combinations. In this case, the output will be the same as shown when using <code>expand()</code> (except row order will be different).</p>
<pre class="r"><code>left_join(mutate(df_lists, id = 1),
          mutate(df_lists, id = 1) %&gt;% rename_at(vars(-one_of(&quot;id&quot;)), paste0, &quot;2&quot;)) %&gt;%
  select(-id)</code></pre>
</div>
<div id="nested-tibbles" class="section level2">
<h2>Nested tibbles</h2>
<p>Creates list of tibbles rather than list of vectors – typically the first way lists as columns in dataframes is introduced.</p>
<pre class="r"><code>ames_subset %&gt;% 
  pivot_longer(everything(), names_to = &quot;var&quot;, values_to = &quot;list&quot;) %&gt;% 
  group_by(var) %&gt;% 
  nest()</code></pre>
</div>
<div id="pivot-and-then-summarise" class="section level2">
<h2>Pivot and then summarise</h2>
<p>(Almost) equivalent to the example in <a href="#i.-nest-and-pivot">I. Nest and pivot</a>. Steps just run in a different order (row order will also be different).</p>
<pre class="r"><code>ames_test %&gt;% 
  pivot_longer(cols = everything(), 
             names_to = &quot;var&quot;, 
             values_to = &quot;vector&quot;) %&gt;% 
  group_by(var) %&gt;% 
  summarise_all(list)</code></pre>
</div>
<div id="session-info" class="section level2">
<h2>Session info</h2>
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>## R version 3.5.1 (2018-07-02)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 18362)
## 
## Matrix products: default
## 
## locale:
## [1] LC_COLLATE=English_United States.1252 
## [2] LC_CTYPE=English_United States.1252   
## [3] LC_MONETARY=English_United States.1252
## [4] LC_NUMERIC=C                          
## [5] LC_TIME=English_United States.1252    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] forcats_0.4.0   stringr_1.4.0   dplyr_0.8.3     purrr_0.3.3    
## [5] readr_1.3.1     tidyr_1.0.0     tibble_2.1.3    ggplot2_3.3.0  
## [9] tidyverse_1.2.1
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_1.0.4        lubridate_1.7.4   lattice_0.20-35  
##  [4] prettyunits_1.0.2 ps_1.3.0          rprojroot_1.3-2  
##  [7] assertthat_0.2.1  digest_0.6.25     utf8_1.1.4       
## [10] R6_2.4.1          cellranger_1.1.0  backports_1.1.5  
## [13] evaluate_0.14     httr_1.4.0        blogdown_0.15    
## [16] pillar_1.4.2      rlang_0.4.5       progress_1.2.2   
## [19] curl_3.3          readxl_1.3.1      rstudioapi_0.10  
## [22] callr_3.2.0       AmesHousing_0.0.3 rmarkdown_1.13   
## [25] desc_1.2.0        labeling_0.3      devtools_2.0.0   
## [28] munsell_0.5.0     broom_0.5.2       compiler_3.5.1   
## [31] modelr_0.1.4      xfun_0.8          pkgconfig_2.0.3  
## [34] pkgbuild_1.0.2    htmltools_0.3.6   tidyselect_0.2.5 
## [37] bookdown_0.11     corrr_0.4.2       fansi_0.4.0      
## [40] crayon_1.3.4      withr_2.1.2       grid_3.5.1       
## [43] nlme_3.1-137      jsonlite_1.6.1    gtable_0.3.0     
## [46] lifecycle_0.1.0   magrittr_1.5      scales_1.1.0     
## [49] cli_1.9.9.9000    stringi_1.4.6     farver_2.0.1     
## [52] fs_1.3.2          remotes_2.1.0     testthat_2.0.0   
## [55] xml2_1.2.0        ellipsis_0.3.0    generics_0.0.2   
## [58] vctrs_0.2.4       tools_3.5.1       glue_1.3.1       
## [61] hms_0.5.2         processx_3.3.1    pkgload_1.0.2    
## [64] yaml_2.2.0        colorspace_1.4-1  sessioninfo_1.1.1
## [67] rvest_0.3.4       memoise_1.1.0     knitr_1.23       
## [70] haven_2.1.0       usethis_1.4.0</code></pre>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Will focus on two-way example in this post, but could use similar methods to make more generalizable solution across n-way examples. If I were to do this, the code below would change. E.g.</p>
<ul>
<li>to use <code>pmap*()</code> operations over <code>map2*()</code> operations</li>
<li>I’d need to make some functions that make it so I can remove all the places where I have <code>var</code> and <code>var2</code> type column names hard-coded</li>
<li>Alternatively, I might shift approaches and make better use of <code>combn()</code></li>
</ul>
<a href="#fnref1" class="footnote-back">↩</a></li>
<li id="fn2"><p>Though this “throw everything and the kitchen-sink” approach may not always be a good idea.<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>I’ve done this type of operation in a variety of ways. Sometimes without any really good reason as to why I used one approach or another. It isn’t completely clear (at least to me) the recommended way of doing these type of operations within the tidyverse – hence the diversity of my approaches in the past and deciding to document the typical steps in the approach I take… via writing this post.<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>Or the tidymodels implementation <code>corrr::correlate()</code> in the <a href="https://corrr.tidymodels.org/">corrr</a> package.<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>I’ll also reference related approaches / small tweaks (putting those materials in the <a href="#appendix">Appendix</a>. This is by no means an exhaustive list (e.g. don’t have an example with a <code>for</code> loop or with a <code>%do%</code> operator). The source code of my post on <a href="https://www.bryanshalloway.com/2020/02/13/fivethirtyeightriddlersolutions-palindrome-debts-and-ambiguous-absolut-value-signs/">Ambiguous Absolute Value</a> signs shows a related but more complex / messy approach on a combinatorics problem.<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>In particular, the chapters on “Iteration” and “Many Models” in <a href="https://r4ds.had.co.nz/iteration.html">R for Data Science</a><a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>The new <code>dplyr</code> 1.0.0. contains new functions that would have been potentially useful for several of these operations. I highly recommend checking these updates out in the various <a href="https://www.tidyverse.org/blog/">recent posts</a> by Hadley Wickham. Some of the major updates (potentially relevant to the types of operations I’ll be discussing in my post):</p>
<ul>
<li>new approach for across-column operations (replacing <code>_at()</code>, <code>_if()</code>, <code>_all()</code> variants with <code>across()</code> function)</li>
<li>brought-back rowwise operations</li>
<li>emphasize ability to output tibbles / multiple columns in core <code>dplyr</code> verbs… This is something I had only taken advantage of occassionally in the past (<a href="https://stackoverflow.com/a/54725732/9059865">example</a>), but will look to use more going forward.]</li>
</ul>
<a href="#fnref7" class="footnote-back">↩</a></li>
<li id="fn8"><p>For technical reasons, I also converted all integer types to doubles – was getting integer overflow problems in later operations before changing. <a href="https://stackoverflow.com/questions/8804779/what-is-integer-overflow-in-r-and-how-can-it-happen">Thread</a> on integer overflow in R. In this post I’m not taking a disciplined approach to feature engineering, however I did standardize the variables so that variable combinations would at least be starting on a similar scale.<a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p>Note that this part of the problem is one where I actually find using <code>tidyr::gather()</code> easier – but I’ve been forcing myself to switch over to using the <code>pivot_()</code> functions over <code>spread()</code> and <code>gather()</code>.<a href="#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p>The more common approach.<a href="#fnref10" class="footnote-back">↩</a></p></li>
<li id="fn11"><p>As switching these would be more computationally efficient – see [When is this approach inappropriate?] for notes related to this.<a href="#fnref11" class="footnote-back">↩</a></p></li>
<li id="fn12"><p>I.e. has the same output regardless of the order of the variables. E.g. multiplication or addition but not subtraction or division.<a href="#fnref12" class="footnote-back">↩</a></p></li>
<li id="fn13"><p>Function(s) that output vectors of length 1 (or less than length of input vectors).<a href="#fnref13" class="footnote-back">↩</a></p></li>
<li id="fn14"><p>Note that the pairwise implementation <code>psych::corr.test()</code> could have been used on your original subsetted dataframe, see <a href="https://stackoverflow.com/questions/13112238/a-matrix-version-of-cor-test">stack overflow thread</a>.<a href="#fnref14" class="footnote-back">↩</a></p></li>
<li id="fn15"><p>Function(s) that output vector of length equal to length of input vectors.<a href="#fnref15" class="footnote-back">↩</a></p></li>
<li id="fn16"><p>Did not print this output because cluttered-up page with so many column names.<a href="#fnref16" class="footnote-back">↩</a></p></li>
<li id="fn17"><p>Steps I - III and V &amp; VI are essentially direct copies of the code above. The approach I took with Step IV may take more effort to follow as it requires understanding a little <code>rlang</code> and could likely have been done more simply.<a href="#fnref17" class="footnote-back">↩</a></p></li>
<li id="fn18"><p>Must have two vectors as input, but do not need to be infix functions.<a href="#fnref18" class="footnote-back">↩</a></p></li>
<li id="fn19"><p>Non-technical article discussing combinatorial explosion in context of company user growth targets: <a href="https://medium.com/@TorBair/exponential-growth-isn-t-cool-combinatorial-growth-is-85a0b1fdb6a5">Exponential Growth Isn’t Cool. Combinatorial Growth Is.</a>.<a href="#fnref19" class="footnote-back">↩</a></p></li>
<li id="fn20"><p>E.g. <a href="https://github.com/Rdatatable/data.table">data.table</a> dataframes<a href="#fnref20" class="footnote-back">↩</a></p></li>
<li id="fn21"><p>Hence, if you are doing operations across combinations of lots of variables it may not make sense to do the operations directly within dataframes.<a href="#fnref21" class="footnote-back">↩</a></p></li>
<li id="fn22"><p>Much (if not most) of the <code>tidyverse</code> (and the R programming language generally) is about creating a smooth interface between the analyst/scientist and the back-end complexity of the operations they are performing. Projects like <a href="https://spark.rstudio.com/">sparklyr</a>, <a href="https://db.rstudio.com/dbi/">DBI</a>, <a href="https://github.com/rstudio/reticulate">reticulate</a>, <a href="https://www.tidymodels.org/">tidymodels</a>, and <a href="https://github.com/paul-buerkner/brms">brms</a> (to name a few) represent cases where this <em>interface</em> role of R is most apparent.<a href="#fnref22" class="footnote-back">↩</a></p></li>
<li id="fn23"><p>For tidyverse packages, this is often returned into or in the form of a dataframe.<a href="#fnref23" class="footnote-back">↩</a></p></li>
<li id="fn24"><p>Could make better use of <code>combn()</code> function to help.<a href="#fnref24" class="footnote-back">↩</a></p></li>
<li id="fn25"><p>Depending on the complexity may just need to brush-up on your linear algebra.<a href="#fnref25" class="footnote-back">↩</a></p></li>
<li id="fn26"><p>and can also be used to run the operation on databases that may have larger data than you could fit on your computer<a href="#fnref26" class="footnote-back">↩</a></p></li>
<li id="fn27"><p>Likely more common for many, if not most, analysts and data scientists.<a href="#fnref27" class="footnote-back">↩</a></p></li>
<li id="fn28"><p>I.e. multiplying two variables together<a href="#fnref28" class="footnote-back">↩</a></p></li>
<li id="fn29"><p>Created upon the recipe being <em>baked</em> or <em>juiced</em> – if you have not checked it out, <a href="https://github.com/tidymodels/recipes">recipes</a> is AWESOME!<a href="#fnref29" class="footnote-back">↩</a></p></li>
<li id="fn30"><p>Maybe at a future date I’ll make a post writing out the example here using the newer approaches now available in <code>tidymodels</code>. <a href="https://gist.github.com/brshallo/674ff06608c1a55fefb8d5dc49896d65">Gist</a> of <code>combn_ttible()</code>… starting place for if I ever get to that write-up.<a href="#fnref30" class="footnote-back">↩</a></p></li>
<li id="fn31"><p>Could also have used <code>right_join()</code> or <code>full_join()</code>.<a href="#fnref31" class="footnote-back">↩</a></p></li>
</ol>
</div>

    </div>
  </article>

  
<section id="comments">
  <div id="disqus_thread"></div>
  <script>
  var disqus_config = function () {
  
  };
  (function() {
    var inIFrame = function() {
      var iframe = true;
      try { iframe = window.self !== window.top; } catch (e) {}
      return iframe;
    };
    if (inIFrame()) return;
    var d = document, s = d.createElement('script');
    s.src = '//bryanshalloway.disqus.com/embed.js'; s.async = true;
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>



</main>

  
      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="/index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/images/hugo-logo.png" width="22" height="22"></a> and <a href="https://bookdown.org/yihui/blogdown/" class="footer-links-kudos">  <img src="/images/hex-blogdown.png" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="/js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>



    
  </body>
</html>

